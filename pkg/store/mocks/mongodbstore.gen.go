// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/aries-framework-go-ext/component/storage/mongodb"
	"github.com/hyperledger/aries-framework-go/spi/storage"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type MongoDBStore struct {
	BatchStub        func([]storage.Operation) error
	batchMutex       sync.RWMutex
	batchArgsForCall []struct {
		arg1 []storage.Operation
	}
	batchReturns struct {
		result1 error
	}
	batchReturnsOnCall map[int]struct {
		result1 error
	}
	BatchAsJSONStub        func([]mongodb.BatchAsJSONOperation) error
	batchAsJSONMutex       sync.RWMutex
	batchAsJSONArgsForCall []struct {
		arg1 []mongodb.BatchAsJSONOperation
	}
	batchAsJSONReturns struct {
		result1 error
	}
	batchAsJSONReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateMongoDBFindOptionsStub        func([]storage.QueryOption, bool) *options.FindOptions
	createMongoDBFindOptionsMutex       sync.RWMutex
	createMongoDBFindOptionsArgsForCall []struct {
		arg1 []storage.QueryOption
		arg2 bool
	}
	createMongoDBFindOptionsReturns struct {
		result1 *options.FindOptions
	}
	createMongoDBFindOptionsReturnsOnCall map[int]struct {
		result1 *options.FindOptions
	}
	DeleteStub        func(string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	FlushStub        func() error
	flushMutex       sync.RWMutex
	flushArgsForCall []struct {
	}
	flushReturns struct {
		result1 error
	}
	flushReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string) ([]byte, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 []byte
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetAsRawMapStub        func(string) (map[string]interface{}, error)
	getAsRawMapMutex       sync.RWMutex
	getAsRawMapArgsForCall []struct {
		arg1 string
	}
	getAsRawMapReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	getAsRawMapReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	GetBulkStub        func(...string) ([][]byte, error)
	getBulkMutex       sync.RWMutex
	getBulkArgsForCall []struct {
		arg1 []string
	}
	getBulkReturns struct {
		result1 [][]byte
		result2 error
	}
	getBulkReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	GetBulkAsRawMapStub        func(...string) ([]map[string]interface{}, error)
	getBulkAsRawMapMutex       sync.RWMutex
	getBulkAsRawMapArgsForCall []struct {
		arg1 []string
	}
	getBulkAsRawMapReturns struct {
		result1 []map[string]interface{}
		result2 error
	}
	getBulkAsRawMapReturnsOnCall map[int]struct {
		result1 []map[string]interface{}
		result2 error
	}
	GetTagsStub        func(string) ([]storage.Tag, error)
	getTagsMutex       sync.RWMutex
	getTagsArgsForCall []struct {
		arg1 string
	}
	getTagsReturns struct {
		result1 []storage.Tag
		result2 error
	}
	getTagsReturnsOnCall map[int]struct {
		result1 []storage.Tag
		result2 error
	}
	PutStub        func(string, []byte, ...storage.Tag) error
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 []storage.Tag
	}
	putReturns struct {
		result1 error
	}
	putReturnsOnCall map[int]struct {
		result1 error
	}
	PutAsJSONStub        func(string, interface{}) error
	putAsJSONMutex       sync.RWMutex
	putAsJSONArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	putAsJSONReturns struct {
		result1 error
	}
	putAsJSONReturnsOnCall map[int]struct {
		result1 error
	}
	QueryStub        func(string, ...storage.QueryOption) (storage.Iterator, error)
	queryMutex       sync.RWMutex
	queryArgsForCall []struct {
		arg1 string
		arg2 []storage.QueryOption
	}
	queryReturns struct {
		result1 storage.Iterator
		result2 error
	}
	queryReturnsOnCall map[int]struct {
		result1 storage.Iterator
		result2 error
	}
	QueryCustomStub        func(interface{}, ...*options.FindOptions) (mongodb.Iterator, error)
	queryCustomMutex       sync.RWMutex
	queryCustomArgsForCall []struct {
		arg1 interface{}
		arg2 []*options.FindOptions
	}
	queryCustomReturns struct {
		result1 mongodb.Iterator
		result2 error
	}
	queryCustomReturnsOnCall map[int]struct {
		result1 mongodb.Iterator
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *MongoDBStore) Batch(arg1 []storage.Operation) error {
	var arg1Copy []storage.Operation
	if arg1 != nil {
		arg1Copy = make([]storage.Operation, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.batchMutex.Lock()
	ret, specificReturn := fake.batchReturnsOnCall[len(fake.batchArgsForCall)]
	fake.batchArgsForCall = append(fake.batchArgsForCall, struct {
		arg1 []storage.Operation
	}{arg1Copy})
	stub := fake.BatchStub
	fakeReturns := fake.batchReturns
	fake.recordInvocation("Batch", []interface{}{arg1Copy})
	fake.batchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) BatchCallCount() int {
	fake.batchMutex.RLock()
	defer fake.batchMutex.RUnlock()
	return len(fake.batchArgsForCall)
}

func (fake *MongoDBStore) BatchCalls(stub func([]storage.Operation) error) {
	fake.batchMutex.Lock()
	defer fake.batchMutex.Unlock()
	fake.BatchStub = stub
}

func (fake *MongoDBStore) BatchArgsForCall(i int) []storage.Operation {
	fake.batchMutex.RLock()
	defer fake.batchMutex.RUnlock()
	argsForCall := fake.batchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) BatchReturns(result1 error) {
	fake.batchMutex.Lock()
	defer fake.batchMutex.Unlock()
	fake.BatchStub = nil
	fake.batchReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) BatchReturnsOnCall(i int, result1 error) {
	fake.batchMutex.Lock()
	defer fake.batchMutex.Unlock()
	fake.BatchStub = nil
	if fake.batchReturnsOnCall == nil {
		fake.batchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.batchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) BatchAsJSON(arg1 []mongodb.BatchAsJSONOperation) error {
	var arg1Copy []mongodb.BatchAsJSONOperation
	if arg1 != nil {
		arg1Copy = make([]mongodb.BatchAsJSONOperation, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.batchAsJSONMutex.Lock()
	ret, specificReturn := fake.batchAsJSONReturnsOnCall[len(fake.batchAsJSONArgsForCall)]
	fake.batchAsJSONArgsForCall = append(fake.batchAsJSONArgsForCall, struct {
		arg1 []mongodb.BatchAsJSONOperation
	}{arg1Copy})
	stub := fake.BatchAsJSONStub
	fakeReturns := fake.batchAsJSONReturns
	fake.recordInvocation("BatchAsJSON", []interface{}{arg1Copy})
	fake.batchAsJSONMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) BatchAsJSONCallCount() int {
	fake.batchAsJSONMutex.RLock()
	defer fake.batchAsJSONMutex.RUnlock()
	return len(fake.batchAsJSONArgsForCall)
}

func (fake *MongoDBStore) BatchAsJSONCalls(stub func([]mongodb.BatchAsJSONOperation) error) {
	fake.batchAsJSONMutex.Lock()
	defer fake.batchAsJSONMutex.Unlock()
	fake.BatchAsJSONStub = stub
}

func (fake *MongoDBStore) BatchAsJSONArgsForCall(i int) []mongodb.BatchAsJSONOperation {
	fake.batchAsJSONMutex.RLock()
	defer fake.batchAsJSONMutex.RUnlock()
	argsForCall := fake.batchAsJSONArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) BatchAsJSONReturns(result1 error) {
	fake.batchAsJSONMutex.Lock()
	defer fake.batchAsJSONMutex.Unlock()
	fake.BatchAsJSONStub = nil
	fake.batchAsJSONReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) BatchAsJSONReturnsOnCall(i int, result1 error) {
	fake.batchAsJSONMutex.Lock()
	defer fake.batchAsJSONMutex.Unlock()
	fake.BatchAsJSONStub = nil
	if fake.batchAsJSONReturnsOnCall == nil {
		fake.batchAsJSONReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.batchAsJSONReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *MongoDBStore) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *MongoDBStore) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) CreateMongoDBFindOptions(arg1 []storage.QueryOption, arg2 bool) *options.FindOptions {
	var arg1Copy []storage.QueryOption
	if arg1 != nil {
		arg1Copy = make([]storage.QueryOption, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.createMongoDBFindOptionsMutex.Lock()
	ret, specificReturn := fake.createMongoDBFindOptionsReturnsOnCall[len(fake.createMongoDBFindOptionsArgsForCall)]
	fake.createMongoDBFindOptionsArgsForCall = append(fake.createMongoDBFindOptionsArgsForCall, struct {
		arg1 []storage.QueryOption
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.CreateMongoDBFindOptionsStub
	fakeReturns := fake.createMongoDBFindOptionsReturns
	fake.recordInvocation("CreateMongoDBFindOptions", []interface{}{arg1Copy, arg2})
	fake.createMongoDBFindOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) CreateMongoDBFindOptionsCallCount() int {
	fake.createMongoDBFindOptionsMutex.RLock()
	defer fake.createMongoDBFindOptionsMutex.RUnlock()
	return len(fake.createMongoDBFindOptionsArgsForCall)
}

func (fake *MongoDBStore) CreateMongoDBFindOptionsCalls(stub func([]storage.QueryOption, bool) *options.FindOptions) {
	fake.createMongoDBFindOptionsMutex.Lock()
	defer fake.createMongoDBFindOptionsMutex.Unlock()
	fake.CreateMongoDBFindOptionsStub = stub
}

func (fake *MongoDBStore) CreateMongoDBFindOptionsArgsForCall(i int) ([]storage.QueryOption, bool) {
	fake.createMongoDBFindOptionsMutex.RLock()
	defer fake.createMongoDBFindOptionsMutex.RUnlock()
	argsForCall := fake.createMongoDBFindOptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *MongoDBStore) CreateMongoDBFindOptionsReturns(result1 *options.FindOptions) {
	fake.createMongoDBFindOptionsMutex.Lock()
	defer fake.createMongoDBFindOptionsMutex.Unlock()
	fake.CreateMongoDBFindOptionsStub = nil
	fake.createMongoDBFindOptionsReturns = struct {
		result1 *options.FindOptions
	}{result1}
}

func (fake *MongoDBStore) CreateMongoDBFindOptionsReturnsOnCall(i int, result1 *options.FindOptions) {
	fake.createMongoDBFindOptionsMutex.Lock()
	defer fake.createMongoDBFindOptionsMutex.Unlock()
	fake.CreateMongoDBFindOptionsStub = nil
	if fake.createMongoDBFindOptionsReturnsOnCall == nil {
		fake.createMongoDBFindOptionsReturnsOnCall = make(map[int]struct {
			result1 *options.FindOptions
		})
	}
	fake.createMongoDBFindOptionsReturnsOnCall[i] = struct {
		result1 *options.FindOptions
	}{result1}
}

func (fake *MongoDBStore) Delete(arg1 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *MongoDBStore) DeleteCalls(stub func(string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *MongoDBStore) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) Flush() error {
	fake.flushMutex.Lock()
	ret, specificReturn := fake.flushReturnsOnCall[len(fake.flushArgsForCall)]
	fake.flushArgsForCall = append(fake.flushArgsForCall, struct {
	}{})
	stub := fake.FlushStub
	fakeReturns := fake.flushReturns
	fake.recordInvocation("Flush", []interface{}{})
	fake.flushMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) FlushCallCount() int {
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	return len(fake.flushArgsForCall)
}

func (fake *MongoDBStore) FlushCalls(stub func() error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = stub
}

func (fake *MongoDBStore) FlushReturns(result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	fake.flushReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) FlushReturnsOnCall(i int, result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	if fake.flushReturnsOnCall == nil {
		fake.flushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) Get(arg1 string) ([]byte, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *MongoDBStore) GetCalls(stub func(string) ([]byte, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *MongoDBStore) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) GetReturns(result1 []byte, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetAsRawMap(arg1 string) (map[string]interface{}, error) {
	fake.getAsRawMapMutex.Lock()
	ret, specificReturn := fake.getAsRawMapReturnsOnCall[len(fake.getAsRawMapArgsForCall)]
	fake.getAsRawMapArgsForCall = append(fake.getAsRawMapArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAsRawMapStub
	fakeReturns := fake.getAsRawMapReturns
	fake.recordInvocation("GetAsRawMap", []interface{}{arg1})
	fake.getAsRawMapMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) GetAsRawMapCallCount() int {
	fake.getAsRawMapMutex.RLock()
	defer fake.getAsRawMapMutex.RUnlock()
	return len(fake.getAsRawMapArgsForCall)
}

func (fake *MongoDBStore) GetAsRawMapCalls(stub func(string) (map[string]interface{}, error)) {
	fake.getAsRawMapMutex.Lock()
	defer fake.getAsRawMapMutex.Unlock()
	fake.GetAsRawMapStub = stub
}

func (fake *MongoDBStore) GetAsRawMapArgsForCall(i int) string {
	fake.getAsRawMapMutex.RLock()
	defer fake.getAsRawMapMutex.RUnlock()
	argsForCall := fake.getAsRawMapArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) GetAsRawMapReturns(result1 map[string]interface{}, result2 error) {
	fake.getAsRawMapMutex.Lock()
	defer fake.getAsRawMapMutex.Unlock()
	fake.GetAsRawMapStub = nil
	fake.getAsRawMapReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetAsRawMapReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.getAsRawMapMutex.Lock()
	defer fake.getAsRawMapMutex.Unlock()
	fake.GetAsRawMapStub = nil
	if fake.getAsRawMapReturnsOnCall == nil {
		fake.getAsRawMapReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.getAsRawMapReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetBulk(arg1 ...string) ([][]byte, error) {
	fake.getBulkMutex.Lock()
	ret, specificReturn := fake.getBulkReturnsOnCall[len(fake.getBulkArgsForCall)]
	fake.getBulkArgsForCall = append(fake.getBulkArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.GetBulkStub
	fakeReturns := fake.getBulkReturns
	fake.recordInvocation("GetBulk", []interface{}{arg1})
	fake.getBulkMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) GetBulkCallCount() int {
	fake.getBulkMutex.RLock()
	defer fake.getBulkMutex.RUnlock()
	return len(fake.getBulkArgsForCall)
}

func (fake *MongoDBStore) GetBulkCalls(stub func(...string) ([][]byte, error)) {
	fake.getBulkMutex.Lock()
	defer fake.getBulkMutex.Unlock()
	fake.GetBulkStub = stub
}

func (fake *MongoDBStore) GetBulkArgsForCall(i int) []string {
	fake.getBulkMutex.RLock()
	defer fake.getBulkMutex.RUnlock()
	argsForCall := fake.getBulkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) GetBulkReturns(result1 [][]byte, result2 error) {
	fake.getBulkMutex.Lock()
	defer fake.getBulkMutex.Unlock()
	fake.GetBulkStub = nil
	fake.getBulkReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetBulkReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.getBulkMutex.Lock()
	defer fake.getBulkMutex.Unlock()
	fake.GetBulkStub = nil
	if fake.getBulkReturnsOnCall == nil {
		fake.getBulkReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.getBulkReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetBulkAsRawMap(arg1 ...string) ([]map[string]interface{}, error) {
	fake.getBulkAsRawMapMutex.Lock()
	ret, specificReturn := fake.getBulkAsRawMapReturnsOnCall[len(fake.getBulkAsRawMapArgsForCall)]
	fake.getBulkAsRawMapArgsForCall = append(fake.getBulkAsRawMapArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.GetBulkAsRawMapStub
	fakeReturns := fake.getBulkAsRawMapReturns
	fake.recordInvocation("GetBulkAsRawMap", []interface{}{arg1})
	fake.getBulkAsRawMapMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) GetBulkAsRawMapCallCount() int {
	fake.getBulkAsRawMapMutex.RLock()
	defer fake.getBulkAsRawMapMutex.RUnlock()
	return len(fake.getBulkAsRawMapArgsForCall)
}

func (fake *MongoDBStore) GetBulkAsRawMapCalls(stub func(...string) ([]map[string]interface{}, error)) {
	fake.getBulkAsRawMapMutex.Lock()
	defer fake.getBulkAsRawMapMutex.Unlock()
	fake.GetBulkAsRawMapStub = stub
}

func (fake *MongoDBStore) GetBulkAsRawMapArgsForCall(i int) []string {
	fake.getBulkAsRawMapMutex.RLock()
	defer fake.getBulkAsRawMapMutex.RUnlock()
	argsForCall := fake.getBulkAsRawMapArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) GetBulkAsRawMapReturns(result1 []map[string]interface{}, result2 error) {
	fake.getBulkAsRawMapMutex.Lock()
	defer fake.getBulkAsRawMapMutex.Unlock()
	fake.GetBulkAsRawMapStub = nil
	fake.getBulkAsRawMapReturns = struct {
		result1 []map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetBulkAsRawMapReturnsOnCall(i int, result1 []map[string]interface{}, result2 error) {
	fake.getBulkAsRawMapMutex.Lock()
	defer fake.getBulkAsRawMapMutex.Unlock()
	fake.GetBulkAsRawMapStub = nil
	if fake.getBulkAsRawMapReturnsOnCall == nil {
		fake.getBulkAsRawMapReturnsOnCall = make(map[int]struct {
			result1 []map[string]interface{}
			result2 error
		})
	}
	fake.getBulkAsRawMapReturnsOnCall[i] = struct {
		result1 []map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetTags(arg1 string) ([]storage.Tag, error) {
	fake.getTagsMutex.Lock()
	ret, specificReturn := fake.getTagsReturnsOnCall[len(fake.getTagsArgsForCall)]
	fake.getTagsArgsForCall = append(fake.getTagsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTagsStub
	fakeReturns := fake.getTagsReturns
	fake.recordInvocation("GetTags", []interface{}{arg1})
	fake.getTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) GetTagsCallCount() int {
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	return len(fake.getTagsArgsForCall)
}

func (fake *MongoDBStore) GetTagsCalls(stub func(string) ([]storage.Tag, error)) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = stub
}

func (fake *MongoDBStore) GetTagsArgsForCall(i int) string {
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	argsForCall := fake.getTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MongoDBStore) GetTagsReturns(result1 []storage.Tag, result2 error) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	fake.getTagsReturns = struct {
		result1 []storage.Tag
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) GetTagsReturnsOnCall(i int, result1 []storage.Tag, result2 error) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	if fake.getTagsReturnsOnCall == nil {
		fake.getTagsReturnsOnCall = make(map[int]struct {
			result1 []storage.Tag
			result2 error
		})
	}
	fake.getTagsReturnsOnCall[i] = struct {
		result1 []storage.Tag
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) Put(arg1 string, arg2 []byte, arg3 ...storage.Tag) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 []storage.Tag
	}{arg1, arg2Copy, arg3})
	stub := fake.PutStub
	fakeReturns := fake.putReturns
	fake.recordInvocation("Put", []interface{}{arg1, arg2Copy, arg3})
	fake.putMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *MongoDBStore) PutCalls(stub func(string, []byte, ...storage.Tag) error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = stub
}

func (fake *MongoDBStore) PutArgsForCall(i int) (string, []byte, []storage.Tag) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	argsForCall := fake.putArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *MongoDBStore) PutReturns(result1 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) PutReturnsOnCall(i int, result1 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) PutAsJSON(arg1 string, arg2 interface{}) error {
	fake.putAsJSONMutex.Lock()
	ret, specificReturn := fake.putAsJSONReturnsOnCall[len(fake.putAsJSONArgsForCall)]
	fake.putAsJSONArgsForCall = append(fake.putAsJSONArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.PutAsJSONStub
	fakeReturns := fake.putAsJSONReturns
	fake.recordInvocation("PutAsJSON", []interface{}{arg1, arg2})
	fake.putAsJSONMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MongoDBStore) PutAsJSONCallCount() int {
	fake.putAsJSONMutex.RLock()
	defer fake.putAsJSONMutex.RUnlock()
	return len(fake.putAsJSONArgsForCall)
}

func (fake *MongoDBStore) PutAsJSONCalls(stub func(string, interface{}) error) {
	fake.putAsJSONMutex.Lock()
	defer fake.putAsJSONMutex.Unlock()
	fake.PutAsJSONStub = stub
}

func (fake *MongoDBStore) PutAsJSONArgsForCall(i int) (string, interface{}) {
	fake.putAsJSONMutex.RLock()
	defer fake.putAsJSONMutex.RUnlock()
	argsForCall := fake.putAsJSONArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *MongoDBStore) PutAsJSONReturns(result1 error) {
	fake.putAsJSONMutex.Lock()
	defer fake.putAsJSONMutex.Unlock()
	fake.PutAsJSONStub = nil
	fake.putAsJSONReturns = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) PutAsJSONReturnsOnCall(i int, result1 error) {
	fake.putAsJSONMutex.Lock()
	defer fake.putAsJSONMutex.Unlock()
	fake.PutAsJSONStub = nil
	if fake.putAsJSONReturnsOnCall == nil {
		fake.putAsJSONReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putAsJSONReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MongoDBStore) Query(arg1 string, arg2 ...storage.QueryOption) (storage.Iterator, error) {
	fake.queryMutex.Lock()
	ret, specificReturn := fake.queryReturnsOnCall[len(fake.queryArgsForCall)]
	fake.queryArgsForCall = append(fake.queryArgsForCall, struct {
		arg1 string
		arg2 []storage.QueryOption
	}{arg1, arg2})
	stub := fake.QueryStub
	fakeReturns := fake.queryReturns
	fake.recordInvocation("Query", []interface{}{arg1, arg2})
	fake.queryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) QueryCallCount() int {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	return len(fake.queryArgsForCall)
}

func (fake *MongoDBStore) QueryCalls(stub func(string, ...storage.QueryOption) (storage.Iterator, error)) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = stub
}

func (fake *MongoDBStore) QueryArgsForCall(i int) (string, []storage.QueryOption) {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	argsForCall := fake.queryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *MongoDBStore) QueryReturns(result1 storage.Iterator, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	fake.queryReturns = struct {
		result1 storage.Iterator
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) QueryReturnsOnCall(i int, result1 storage.Iterator, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	if fake.queryReturnsOnCall == nil {
		fake.queryReturnsOnCall = make(map[int]struct {
			result1 storage.Iterator
			result2 error
		})
	}
	fake.queryReturnsOnCall[i] = struct {
		result1 storage.Iterator
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) QueryCustom(arg1 interface{}, arg2 ...*options.FindOptions) (mongodb.Iterator, error) {
	fake.queryCustomMutex.Lock()
	ret, specificReturn := fake.queryCustomReturnsOnCall[len(fake.queryCustomArgsForCall)]
	fake.queryCustomArgsForCall = append(fake.queryCustomArgsForCall, struct {
		arg1 interface{}
		arg2 []*options.FindOptions
	}{arg1, arg2})
	stub := fake.QueryCustomStub
	fakeReturns := fake.queryCustomReturns
	fake.recordInvocation("QueryCustom", []interface{}{arg1, arg2})
	fake.queryCustomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MongoDBStore) QueryCustomCallCount() int {
	fake.queryCustomMutex.RLock()
	defer fake.queryCustomMutex.RUnlock()
	return len(fake.queryCustomArgsForCall)
}

func (fake *MongoDBStore) QueryCustomCalls(stub func(interface{}, ...*options.FindOptions) (mongodb.Iterator, error)) {
	fake.queryCustomMutex.Lock()
	defer fake.queryCustomMutex.Unlock()
	fake.QueryCustomStub = stub
}

func (fake *MongoDBStore) QueryCustomArgsForCall(i int) (interface{}, []*options.FindOptions) {
	fake.queryCustomMutex.RLock()
	defer fake.queryCustomMutex.RUnlock()
	argsForCall := fake.queryCustomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *MongoDBStore) QueryCustomReturns(result1 mongodb.Iterator, result2 error) {
	fake.queryCustomMutex.Lock()
	defer fake.queryCustomMutex.Unlock()
	fake.QueryCustomStub = nil
	fake.queryCustomReturns = struct {
		result1 mongodb.Iterator
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) QueryCustomReturnsOnCall(i int, result1 mongodb.Iterator, result2 error) {
	fake.queryCustomMutex.Lock()
	defer fake.queryCustomMutex.Unlock()
	fake.QueryCustomStub = nil
	if fake.queryCustomReturnsOnCall == nil {
		fake.queryCustomReturnsOnCall = make(map[int]struct {
			result1 mongodb.Iterator
			result2 error
		})
	}
	fake.queryCustomReturnsOnCall[i] = struct {
		result1 mongodb.Iterator
		result2 error
	}{result1, result2}
}

func (fake *MongoDBStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.batchMutex.RLock()
	defer fake.batchMutex.RUnlock()
	fake.batchAsJSONMutex.RLock()
	defer fake.batchAsJSONMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createMongoDBFindOptionsMutex.RLock()
	defer fake.createMongoDBFindOptionsMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getAsRawMapMutex.RLock()
	defer fake.getAsRawMapMutex.RUnlock()
	fake.getBulkMutex.RLock()
	defer fake.getBulkMutex.RUnlock()
	fake.getBulkAsRawMapMutex.RLock()
	defer fake.getBulkAsRawMapMutex.RUnlock()
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	fake.putAsJSONMutex.RLock()
	defer fake.putAsJSONMutex.RUnlock()
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	fake.queryCustomMutex.RLock()
	defer fake.queryCustomMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *MongoDBStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
