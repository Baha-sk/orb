// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"net/url"
	"sync"

	"github.com/trustbloc/orb/pkg/activitypub/client"
	"github.com/trustbloc/orb/pkg/activitypub/vocab"
)

type ActivityIterator struct {
	NextStub        func() (*vocab.ActivityType, error)
	nextMutex       sync.RWMutex
	nextArgsForCall []struct{}
	nextReturns     struct {
		result1 *vocab.ActivityType
		result2 error
	}
	nextReturnsOnCall map[int]struct {
		result1 *vocab.ActivityType
		result2 error
	}
	NextPageStub        func() (*url.URL, error)
	nextPageMutex       sync.RWMutex
	nextPageArgsForCall []struct{}
	nextPageReturns     struct {
		result1 *url.URL
		result2 error
	}
	nextPageReturnsOnCall map[int]struct {
		result1 *url.URL
		result2 error
	}
	SetNextIndexStub        func(int)
	setNextIndexMutex       sync.RWMutex
	setNextIndexArgsForCall []struct {
		arg1 int
	}
	TotalItemsStub        func() int
	totalItemsMutex       sync.RWMutex
	totalItemsArgsForCall []struct{}
	totalItemsReturns     struct {
		result1 int
	}
	totalItemsReturnsOnCall map[int]struct {
		result1 int
	}
	CurrentPageStub        func() *url.URL
	currentPageMutex       sync.RWMutex
	currentPageArgsForCall []struct{}
	currentPageReturns     struct {
		result1 *url.URL
	}
	currentPageReturnsOnCall map[int]struct {
		result1 *url.URL
	}
	NextIndexStub        func() int
	nextIndexMutex       sync.RWMutex
	nextIndexArgsForCall []struct{}
	nextIndexReturns     struct {
		result1 int
	}
	nextIndexReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ActivityIterator) Next() (*vocab.ActivityType, error) {
	fake.nextMutex.Lock()
	ret, specificReturn := fake.nextReturnsOnCall[len(fake.nextArgsForCall)]
	fake.nextArgsForCall = append(fake.nextArgsForCall, struct{}{})
	fake.recordInvocation("Next", []interface{}{})
	fake.nextMutex.Unlock()
	if fake.NextStub != nil {
		return fake.NextStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nextReturns.result1, fake.nextReturns.result2
}

func (fake *ActivityIterator) NextCallCount() int {
	fake.nextMutex.RLock()
	defer fake.nextMutex.RUnlock()
	return len(fake.nextArgsForCall)
}

func (fake *ActivityIterator) NextReturns(result1 *vocab.ActivityType, result2 error) {
	fake.NextStub = nil
	fake.nextReturns = struct {
		result1 *vocab.ActivityType
		result2 error
	}{result1, result2}
}

func (fake *ActivityIterator) NextReturnsOnCall(i int, result1 *vocab.ActivityType, result2 error) {
	fake.NextStub = nil
	if fake.nextReturnsOnCall == nil {
		fake.nextReturnsOnCall = make(map[int]struct {
			result1 *vocab.ActivityType
			result2 error
		})
	}
	fake.nextReturnsOnCall[i] = struct {
		result1 *vocab.ActivityType
		result2 error
	}{result1, result2}
}

func (fake *ActivityIterator) NextPage() (*url.URL, error) {
	fake.nextPageMutex.Lock()
	ret, specificReturn := fake.nextPageReturnsOnCall[len(fake.nextPageArgsForCall)]
	fake.nextPageArgsForCall = append(fake.nextPageArgsForCall, struct{}{})
	fake.recordInvocation("NextPage", []interface{}{})
	fake.nextPageMutex.Unlock()
	if fake.NextPageStub != nil {
		return fake.NextPageStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nextPageReturns.result1, fake.nextPageReturns.result2
}

func (fake *ActivityIterator) NextPageCallCount() int {
	fake.nextPageMutex.RLock()
	defer fake.nextPageMutex.RUnlock()
	return len(fake.nextPageArgsForCall)
}

func (fake *ActivityIterator) NextPageReturns(result1 *url.URL, result2 error) {
	fake.NextPageStub = nil
	fake.nextPageReturns = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *ActivityIterator) NextPageReturnsOnCall(i int, result1 *url.URL, result2 error) {
	fake.NextPageStub = nil
	if fake.nextPageReturnsOnCall == nil {
		fake.nextPageReturnsOnCall = make(map[int]struct {
			result1 *url.URL
			result2 error
		})
	}
	fake.nextPageReturnsOnCall[i] = struct {
		result1 *url.URL
		result2 error
	}{result1, result2}
}

func (fake *ActivityIterator) SetNextIndex(arg1 int) {
	fake.setNextIndexMutex.Lock()
	fake.setNextIndexArgsForCall = append(fake.setNextIndexArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("SetNextIndex", []interface{}{arg1})
	fake.setNextIndexMutex.Unlock()
	if fake.SetNextIndexStub != nil {
		fake.SetNextIndexStub(arg1)
	}
}

func (fake *ActivityIterator) SetNextIndexCallCount() int {
	fake.setNextIndexMutex.RLock()
	defer fake.setNextIndexMutex.RUnlock()
	return len(fake.setNextIndexArgsForCall)
}

func (fake *ActivityIterator) SetNextIndexArgsForCall(i int) int {
	fake.setNextIndexMutex.RLock()
	defer fake.setNextIndexMutex.RUnlock()
	return fake.setNextIndexArgsForCall[i].arg1
}

func (fake *ActivityIterator) TotalItems() int {
	fake.totalItemsMutex.Lock()
	ret, specificReturn := fake.totalItemsReturnsOnCall[len(fake.totalItemsArgsForCall)]
	fake.totalItemsArgsForCall = append(fake.totalItemsArgsForCall, struct{}{})
	fake.recordInvocation("TotalItems", []interface{}{})
	fake.totalItemsMutex.Unlock()
	if fake.TotalItemsStub != nil {
		return fake.TotalItemsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.totalItemsReturns.result1
}

func (fake *ActivityIterator) TotalItemsCallCount() int {
	fake.totalItemsMutex.RLock()
	defer fake.totalItemsMutex.RUnlock()
	return len(fake.totalItemsArgsForCall)
}

func (fake *ActivityIterator) TotalItemsReturns(result1 int) {
	fake.TotalItemsStub = nil
	fake.totalItemsReturns = struct {
		result1 int
	}{result1}
}

func (fake *ActivityIterator) TotalItemsReturnsOnCall(i int, result1 int) {
	fake.TotalItemsStub = nil
	if fake.totalItemsReturnsOnCall == nil {
		fake.totalItemsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.totalItemsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ActivityIterator) CurrentPage() *url.URL {
	fake.currentPageMutex.Lock()
	ret, specificReturn := fake.currentPageReturnsOnCall[len(fake.currentPageArgsForCall)]
	fake.currentPageArgsForCall = append(fake.currentPageArgsForCall, struct{}{})
	fake.recordInvocation("CurrentPage", []interface{}{})
	fake.currentPageMutex.Unlock()
	if fake.CurrentPageStub != nil {
		return fake.CurrentPageStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.currentPageReturns.result1
}

func (fake *ActivityIterator) CurrentPageCallCount() int {
	fake.currentPageMutex.RLock()
	defer fake.currentPageMutex.RUnlock()
	return len(fake.currentPageArgsForCall)
}

func (fake *ActivityIterator) CurrentPageReturns(result1 *url.URL) {
	fake.CurrentPageStub = nil
	fake.currentPageReturns = struct {
		result1 *url.URL
	}{result1}
}

func (fake *ActivityIterator) CurrentPageReturnsOnCall(i int, result1 *url.URL) {
	fake.CurrentPageStub = nil
	if fake.currentPageReturnsOnCall == nil {
		fake.currentPageReturnsOnCall = make(map[int]struct {
			result1 *url.URL
		})
	}
	fake.currentPageReturnsOnCall[i] = struct {
		result1 *url.URL
	}{result1}
}

func (fake *ActivityIterator) NextIndex() int {
	fake.nextIndexMutex.Lock()
	ret, specificReturn := fake.nextIndexReturnsOnCall[len(fake.nextIndexArgsForCall)]
	fake.nextIndexArgsForCall = append(fake.nextIndexArgsForCall, struct{}{})
	fake.recordInvocation("NextIndex", []interface{}{})
	fake.nextIndexMutex.Unlock()
	if fake.NextIndexStub != nil {
		return fake.NextIndexStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nextIndexReturns.result1
}

func (fake *ActivityIterator) NextIndexCallCount() int {
	fake.nextIndexMutex.RLock()
	defer fake.nextIndexMutex.RUnlock()
	return len(fake.nextIndexArgsForCall)
}

func (fake *ActivityIterator) NextIndexReturns(result1 int) {
	fake.NextIndexStub = nil
	fake.nextIndexReturns = struct {
		result1 int
	}{result1}
}

func (fake *ActivityIterator) NextIndexReturnsOnCall(i int, result1 int) {
	fake.NextIndexStub = nil
	if fake.nextIndexReturnsOnCall == nil {
		fake.nextIndexReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.nextIndexReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ActivityIterator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nextMutex.RLock()
	defer fake.nextMutex.RUnlock()
	fake.nextPageMutex.RLock()
	defer fake.nextPageMutex.RUnlock()
	fake.setNextIndexMutex.RLock()
	defer fake.setNextIndexMutex.RUnlock()
	fake.totalItemsMutex.RLock()
	defer fake.totalItemsMutex.RUnlock()
	fake.currentPageMutex.RLock()
	defer fake.currentPageMutex.RUnlock()
	fake.nextIndexMutex.RLock()
	defer fake.nextIndexMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ActivityIterator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.ActivityIterator = new(ActivityIterator)
