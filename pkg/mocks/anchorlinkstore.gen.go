// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"net/url"
	"sync"
)

type AnchorLinkStore struct {
	PutLinksStub        func(links []*url.URL) error
	putLinksMutex       sync.RWMutex
	putLinksArgsForCall []struct {
		links []*url.URL
	}
	putLinksReturns struct {
		result1 error
	}
	putLinksReturnsOnCall map[int]struct {
		result1 error
	}
	GetLinksStub        func(anchorHash string) ([]*url.URL, error)
	getLinksMutex       sync.RWMutex
	getLinksArgsForCall []struct {
		anchorHash string
	}
	getLinksReturns struct {
		result1 []*url.URL
		result2 error
	}
	getLinksReturnsOnCall map[int]struct {
		result1 []*url.URL
		result2 error
	}
	DeleteLinksStub        func(links []*url.URL) error
	deleteLinksMutex       sync.RWMutex
	deleteLinksArgsForCall []struct {
		links []*url.URL
	}
	deleteLinksReturns struct {
		result1 error
	}
	deleteLinksReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *AnchorLinkStore) PutLinks(links []*url.URL) error {
	var linksCopy []*url.URL
	if links != nil {
		linksCopy = make([]*url.URL, len(links))
		copy(linksCopy, links)
	}
	fake.putLinksMutex.Lock()
	ret, specificReturn := fake.putLinksReturnsOnCall[len(fake.putLinksArgsForCall)]
	fake.putLinksArgsForCall = append(fake.putLinksArgsForCall, struct {
		links []*url.URL
	}{linksCopy})
	fake.recordInvocation("PutLinks", []interface{}{linksCopy})
	fake.putLinksMutex.Unlock()
	if fake.PutLinksStub != nil {
		return fake.PutLinksStub(links)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putLinksReturns.result1
}

func (fake *AnchorLinkStore) PutLinksCallCount() int {
	fake.putLinksMutex.RLock()
	defer fake.putLinksMutex.RUnlock()
	return len(fake.putLinksArgsForCall)
}

func (fake *AnchorLinkStore) PutLinksArgsForCall(i int) []*url.URL {
	fake.putLinksMutex.RLock()
	defer fake.putLinksMutex.RUnlock()
	return fake.putLinksArgsForCall[i].links
}

func (fake *AnchorLinkStore) PutLinksReturns(result1 error) {
	fake.PutLinksStub = nil
	fake.putLinksReturns = struct {
		result1 error
	}{result1}
}

func (fake *AnchorLinkStore) PutLinksReturnsOnCall(i int, result1 error) {
	fake.PutLinksStub = nil
	if fake.putLinksReturnsOnCall == nil {
		fake.putLinksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putLinksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *AnchorLinkStore) GetLinks(anchorHash string) ([]*url.URL, error) {
	fake.getLinksMutex.Lock()
	ret, specificReturn := fake.getLinksReturnsOnCall[len(fake.getLinksArgsForCall)]
	fake.getLinksArgsForCall = append(fake.getLinksArgsForCall, struct {
		anchorHash string
	}{anchorHash})
	fake.recordInvocation("GetLinks", []interface{}{anchorHash})
	fake.getLinksMutex.Unlock()
	if fake.GetLinksStub != nil {
		return fake.GetLinksStub(anchorHash)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getLinksReturns.result1, fake.getLinksReturns.result2
}

func (fake *AnchorLinkStore) GetLinksCallCount() int {
	fake.getLinksMutex.RLock()
	defer fake.getLinksMutex.RUnlock()
	return len(fake.getLinksArgsForCall)
}

func (fake *AnchorLinkStore) GetLinksArgsForCall(i int) string {
	fake.getLinksMutex.RLock()
	defer fake.getLinksMutex.RUnlock()
	return fake.getLinksArgsForCall[i].anchorHash
}

func (fake *AnchorLinkStore) GetLinksReturns(result1 []*url.URL, result2 error) {
	fake.GetLinksStub = nil
	fake.getLinksReturns = struct {
		result1 []*url.URL
		result2 error
	}{result1, result2}
}

func (fake *AnchorLinkStore) GetLinksReturnsOnCall(i int, result1 []*url.URL, result2 error) {
	fake.GetLinksStub = nil
	if fake.getLinksReturnsOnCall == nil {
		fake.getLinksReturnsOnCall = make(map[int]struct {
			result1 []*url.URL
			result2 error
		})
	}
	fake.getLinksReturnsOnCall[i] = struct {
		result1 []*url.URL
		result2 error
	}{result1, result2}
}

func (fake *AnchorLinkStore) DeleteLinks(links []*url.URL) error {
	var linksCopy []*url.URL
	if links != nil {
		linksCopy = make([]*url.URL, len(links))
		copy(linksCopy, links)
	}
	fake.deleteLinksMutex.Lock()
	ret, specificReturn := fake.deleteLinksReturnsOnCall[len(fake.deleteLinksArgsForCall)]
	fake.deleteLinksArgsForCall = append(fake.deleteLinksArgsForCall, struct {
		links []*url.URL
	}{linksCopy})
	fake.recordInvocation("DeleteLinks", []interface{}{linksCopy})
	fake.deleteLinksMutex.Unlock()
	if fake.DeleteLinksStub != nil {
		return fake.DeleteLinksStub(links)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteLinksReturns.result1
}

func (fake *AnchorLinkStore) DeleteLinksCallCount() int {
	fake.deleteLinksMutex.RLock()
	defer fake.deleteLinksMutex.RUnlock()
	return len(fake.deleteLinksArgsForCall)
}

func (fake *AnchorLinkStore) DeleteLinksArgsForCall(i int) []*url.URL {
	fake.deleteLinksMutex.RLock()
	defer fake.deleteLinksMutex.RUnlock()
	return fake.deleteLinksArgsForCall[i].links
}

func (fake *AnchorLinkStore) DeleteLinksReturns(result1 error) {
	fake.DeleteLinksStub = nil
	fake.deleteLinksReturns = struct {
		result1 error
	}{result1}
}

func (fake *AnchorLinkStore) DeleteLinksReturnsOnCall(i int, result1 error) {
	fake.DeleteLinksStub = nil
	if fake.deleteLinksReturnsOnCall == nil {
		fake.deleteLinksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteLinksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *AnchorLinkStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.putLinksMutex.RLock()
	defer fake.putLinksMutex.RUnlock()
	fake.getLinksMutex.RLock()
	defer fake.getLinksMutex.RUnlock()
	fake.deleteLinksMutex.RLock()
	defer fake.deleteLinksMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *AnchorLinkStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
